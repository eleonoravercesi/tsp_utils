"""
This module contains functions to solve the Symmetric Traveling Salesman Problem
Author: Eleonora Vercesi
Date: Sept 2025

Functions
----------
- solve_tsp: Solve the TSP using a branch-and-cut approach with PySCIPOpt
- solve_tsp_fixed_edge: Solve the TSP forcing an edge to be in the solution
- run_concorde: Run the Concorde TSP solver on a given graph
- create_tsp_problem_object: Create a TSPLIB problem object from a NetworkX graph
- parse_log: Parse the log file generated by Concorde
- write_tsplib: Write a TSPLIB file from a NetworkX graph
"""
import networkx
import networkx as nx
from pyscipopt import Model, quicksum
import pathlib
import tsplib95
import os
import subprocess
from itertools import combinations
from math import ceil

def delta(S, edges):
    """
    Returns the edges having exactly one endpoint in S

    Parameters
    ----------
    S : set
        Set of nodes in the graph
    edges : list
        List of edges in the graph

    Returns
    -------
    list
        List of edges having exactly one endpoint in S
    """
    return [e for e in edges if (e[0] in S) != (e[1] in S)]


def solve_tsp(G, cost="weight", verbose=False):
    """
    Adapted from https://github.com/scipopt/PySCIPOpt/blob/master/examples/finished/tsp.py
    Parameters
    ----------
    G : networkx.Graph
        NetworkX graph
    cost : string
        Cost function, must be one of the edges attributes. Default: 'weight'
    verbose : bool
        Whether to print verbose output. Default: False

    Returns:
    --------
    TODO
    """


    def addcut(cut_edges):
        G = networkx.Graph()
        G.add_edges_from(cut_edges)
        Components = list(networkx.connected_components(G))

        if len(Components) == 1:
            return False
        model.freeTransform()
        for S in Components:
            T = set(V) - set(S)
            model.addCons(quicksum(x[i, j] for i in S for j in T if j > i) +
                          quicksum(x[i, j] for i in T for j in S if j > i) >= 2)
        return True

    # main part of the solution process:
    model = Model()

    if not verbose:
        model.hideOutput()  # silent/verbose mode

    n = G.number_of_nodes()
    edges = [(i, j) for i in range(n) for j in range(i + 1, n)]
    V = range(n)

    x = {}
    for e in edges:
        i, j = e
        x[i, j] = model.addVar(vtype="I", lb=0, ub=1, name="x(%s,%s)" % (i, j))

    for i in V:
        model.addCons(quicksum(x[u, v] for (u, v) in delta({i}, edges)) == 2, "degree(%s)" % i)

    model.setObjective(quicksum(G[e[0]][e[1]][cost] * x[e[0], e[1]] for e in edges), "minimize")

    EPS = 1.e-6
    isMIP = False
    while True:
        model.optimize()
        non_zero_edges = []
        for (i, j) in x:
            if model.getVal(x[i, j]) > EPS:
                non_zero_edges.append((i, j))

        if addcut(non_zero_edges) == False:
            if isMIP:  # integer variables, components connected: solution found
                break
            model.freeTransform()
            for (i, j) in x:  # all components connected, switch to integer model
                model.chgVarType(x[i, j], "B")
                isMIP = True

    # Get the runtime
    runtime = model.getTotalTime()

    return model.getObjVal(), non_zero_edges, runtime


def solve_tsp_fixed_edge(G, e=None, cost="weight", verbose=False):
    """
    Adapted from https://github.com/scipopt/PySCIPOpt/blob/master/examples/finished/tsp.py

    Solve the TSP by forcing an edge beeing in the solution

    Parameters
    ----------
    G : networkx.Graph
        NetworkX graph
    cost : string
        Cost function, must be one of the edges attributes. Default: 'weight'
    verbose : bool
        Whether to print verbose output. Default: False

    Returns:
    --------
    opt: float
        Optimal value of the objective function
    edges: list
        List of edges in the optimal solution
    """
    if e is None:
        raise ValueError("Edge must be provided")

    def addcut(cut_edges):
        G = networkx.Graph()
        G.add_edges_from(cut_edges)
        Components = list(networkx.connected_components(G))

        if len(Components) == 1:
            return False
        model.freeTransform()
        for S in Components:
            T = set(V) - set(S)
            model.addCons(quicksum(x[i, j] for i in S for j in T if j > i) +
                          quicksum(x[i, j] for i in T for j in S if j > i) >= 2)
        return True

    # main part of the solution process:
    model = Model()

    if not verbose:
        model.hideOutput()  # silent/verbose mode

    n = G.number_of_nodes()
    edges = [(i, j) for i in range(n) for j in range(i + 1, n)]
    V = range(n)

    x = {}
    for e in edges:
        i, j = e
        x[i, j] = model.addVar(vtype="C", lb=0, ub=1, name="x(%s,%s)" % (i, j))

    # Add the fixed edge constrant
    i, j = e
    model.addCons(x[i, j] == 1, "fixed_edge(%s,%s)" % (i, j))

    for i in V:
        model.addCons(quicksum(x[u, v] for (u, v) in delta({i}, edges)) == 2, "degree(%s)" % i)

    model.setObjective(quicksum(G[e[0]][e[1]][cost] * x[e[0], e[1]] for e in edges), "minimize")

    EPS = 1.e-6
    isMIP = False
    while True:
        model.optimize()
        non_zero_edges = []
        for (i, j) in x:
            if model.getVal(x[i, j]) > EPS:
                non_zero_edges.append((i, j))

        if addcut(non_zero_edges) == False:
            if isMIP:  # integer variables, components connected: solution found
                break
            model.freeTransform()
            for (i, j) in x:  # all components connected, switch to integer model
                model.chgVarType(x[i, j], "B")
                isMIP = True

    # Return the runtime
    runtime = model.getTotalTime()


    return model.getObjVal(), non_zero_edges, runtime

def create_tsp_problem_object(G, cost="weight"):
    problem = tsplib95.models.StandardProblem()
    problem.name = "tmp"
    problem.type = "TSP"
    problem.dimension = G.number_of_nodes()
    problem.edge_weight_type = "EXPLICIT"
    problem.edge_weight_format = "UPPER_ROW"
    edge_weight_section = []
    for i in range(problem.dimension):
        for j in range(i + 1, problem.dimension):
            edge_weight_section.append(int(G[i][j][cost]))
    problem.edge_weights = [edge_weight_section]
    return problem

def parse_log(filename):
    F = open(filename)
    lines = F.readlines()
    F.close()
    ot_line = next(filter(lambda x : "Optimal Solution:" in x, list(lines.__reversed__())))
    bb_nodes_line = ""
    try:
        bb_nodes_line = next(filter(lambda x : "Number of bbnodes:" in x, list(lines.__reversed__())))
    except:
        pass
    time_line = next(filter(lambda x : "Total Running Time:" in x , list(lines.__reversed__())))
    ot = float(ot_line.split(":")[1].strip())
    bb_nodes = 0
    if len(bb_nodes_line) >= 1:
        bb_nodes = float(bb_nodes_line.split(":")[1].strip())
    time = float(time_line.split(":")[1].split("(")[0])
    return ot, bb_nodes, time

def parse_sol(filename, as_tour = False, as_list_of_edges = False):
    """
    Parse the solution file generated by Concorde.

    Parameters
    ----------
    filename : str
        The name of the solution file.
    as_tour : bool
        If True, return the tour as a list of nodes.
    as_list_of_edges : bool
        If True, return the tour as a list of edges.

    Returns
    -------
    X : list
        The tour as a list of nodes or edges. If it is a list of nodes, it ends with the first node, that is most likely 0
    """
    # Just one between as_tour and as_list_of_edges must be True
    assert as_tour != as_list_of_edges, "Only one of as_tour and as_list_of_edges must be True"

    # Open the sol file
    F = open(filename, "r")

    # Skip the first line
    F.readline()

    # Read the other lines
    lines = F.readlines()

    nodes = []
    for line in lines:
        line_vec = line.strip().split(" ")
        for u in line_vec:
            if len(u) > 0:
                nodes.append(int(u))

    nodes += [nodes[0]]
    if as_tour:
        return nodes

    else:
        edges = []
        for i in range(len(nodes) - 1):
            u = min(nodes[i], nodes[i + 1])
            v = max(nodes[i], nodes[i + 1])
            edges.append((u, v))
        return edges

def run_concorde(G, cost="weight", concorde_path=None, seed = None, options=[], verbose=False, remove_all=False, get_tour = False, get_edges = False):
    """
    Run the Concorde TSP solver on a given graph.

    Parameters
    ----------
    G : networkx.Graph
        The graph to solve.
    concorde_path : str
    # TODO
    """
    assert concorde_path != None, "Concorde path must be provided"

    concorde_path = pathlib.Path(concorde_path)

    # Create a directory named tmp to store temporary files
    tmp_dir = "./tmp/"
    pathlib.Path(tmp_dir).mkdir(parents=True, exist_ok=True)

    if type(G) == nx.Graph:
        problem = create_tsp_problem_object(G, cost=cost)
        tsp_file = tmp_dir + "tmp.tsp"
        with open(tsp_file, 'w') as f:
            problem.write(f)
    else:
        F = open(G, "r")
        lines = F.read()
        F.close()
        F = open(tmp_dir + "tmp.tsp", "w+")
        F.write(lines)
        F.close()

    # Change the directory
    os.chdir(tmp_dir)

    # ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐
    # Run Concorde
    # ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐

    # is verbose?
    if not verbose:
        options += ["-x"]
    # Do we want to use the seed?
    if seed != None:
        options += ["-s {}".format(seed)]

    # Merge all the options together
    options = " ".join(options)

    # ~/libraries/concorde/build/TSP/concorde tmp.tsp > tmp.log
    subprocess.run(f"{concorde_path} {options} tmp.tsp > tmp.log", shell=True)
    ot, bb_nodes, time = parse_log("tmp.log")

    # Now, if you also want the tour
    if get_tour:
        # Open the sol file
        X_t = parse_sol("tmp.sol", as_tour=True)
    if get_edges:
        X_e = parse_sol("tmp.sol", as_list_of_edges=True)

    # Return to the original directory
    os.chdir("..")

    if remove_all:
        # Remove the tmp directory
        os.rmdir(tmp_dir, recursive=True)
    if get_tour and not get_edges:
        return ot, bb_nodes, time, X_t
    if get_edges and not get_tour:
        return ot, bb_nodes, time, X_e
    if get_tour and get_edges:
        return ot, bb_nodes, time, X_t, X_e

    # Just return the optimal value and the bb nodes
    return ot, bb_nodes, time

def run_concorde_LB(G, cost="weight", concorde_path=None, seed = None, options=[], verbose=False, remove_all=False):

    # Just the LB
    options += ["-I"]

    return run_concorde(G, cost=cost, concorde_path=concorde_path, options=options, seed=seed, verbose=verbose, remove_all=remove_all, get_tour=False)

def S_set(n):
    """
    Generate all the sets S such that 3 <= |S| <= ceil(n/2)

    Parameters
    ----------
    n : int
        The number of nodes in the graph.

    Returns
    -------
    list
        A list of sets S.
    """
    S = []
    nodes = list(range(n))
    for r in range(3, ceil(n // 2) + 1):
        comb = combinations(nodes, r)
        for c in comb:
            S.append(set(c))
    return S

def dual_sep(G, cost = "weight", verbose=False, write=False):
    """
    Solve the dual formulation of the Dantzig-Fulkerson-Johnson formulation, that can be find, for instance, here: https://static.aminer.org/pdf/PDF/000/406/746/finding_the_exact_integrality_gap_for_small_traveling_salesman_problems.pdf
    Equation (15) - (18)
    Parameters
    ----------
    G : networkx.Graph
        NetworkX graph
    cost : string
        Cost function, must be one of the edges attributes. Default: 'weight'
    verbose : bool
        Whether to print verbose output. Default: False
    Returns
    -------
    y : dict
        The dual variables for the degree constraints.
    d : dict
        The dual variables for the cut constraints.
    u : dict
        The dual variables for the upper bound constraints.
    obj_val : float
        The optimal value of the dual problem.
    # TODO may be optimized by adding column generation
    """

    # main part of the solution process:
    model = Model()

    if not verbose:
        model.hideOutput()  # silent/verbose mode

    n = G.number_of_nodes()
    edges = [(i, j) for i in range(n) for j in range(i + 1, n)]
    V = range(n)

    # Add dual variables for the degree constraints
    y = {}
    for i in V:
        y[i] = model.addVar(vtype="C", name="y(%s)" % i) # Free

    # Add dual variables for the upper bound constraints
    u = {}
    for e in edges:
        u[e] = model.addVar(vtype="C", name="u(%s,%s)" % (e[0], e[1]), lb=0) # >= 0

    # Add dual variables for the cut constraints
    d = {}
    S_all = S_set(n)
    for S in S_all:
        d[frozenset(S)] = model.addVar(vtype="C", name="d(%s)" % str(S), lb=0) # >= 0

    # Add the constraints
    for i, j in edges:
        model.addCons(y[i] + y[j] - u[i, j] + quicksum(d[frozenset(S)] for S in S_all if (i, j) in delta(S, edges)) <= G[i][j][cost], "edge(%s,%s)" % (i, j))

    model.setObjective(quicksum(2 * y[i] for i in V) - quicksum(u[e] for e in edges) + 2 * quicksum(d[frozenset(S)] for S in S_all), "maximize")

    model.optimize()

    # Now return the values of the dual variables
    y_val = {i: model.getVal(y[i]) for i in V}
    u_val = {e: model.getVal(u[e]) for e in edges}
    d_val = {S: model.getVal(d[S]) for S in d.keys()}
    obj_val = model.getObjVal()

    # Write the model in .lp file
    if write:
        model.writeProblem("dual_sep.lp")
        print("Model written in dual_sep.lp")

    return y_val, d_val, u_val, obj_val

def solve_sep(G, cost="weight", verbose=False, time_limit=None, tol=1e-6):
    """
    Solve the subtour elimination problem, that is, linear relaxation of the Dantzig-Fulkerson-Johnson formulation with all the subtour elimination constraints.
    Parameters
    ----------
    G : networkx.Graph
        NetworkX graph
    cost : string
        Cost function, must be one of the edges attributes. Default: 'weight'
    verbose : bool
        Whether to print verbose output. Default: False
    time_limit : float
        Time limit for the solver. Default: None
    tol : float
        Tolerance for the cut constraints. Default: 1e-6

    Returns
    -------
    obj_val : float
        The optimal value of the primal problem.
    x : dict
        The primal variables for the edges.
    runtime : float
        The runtime of the solver.
    """


    n = G.number_of_nodes()
    edges = [(i, j) for i in range(n) for j in range(i + 1, n)]

    # Create the model
    model = Model("STSP_LP")
    if verbose < 2:
        model.hideOutput()
    if time_limit is not None:
        model.setRealParam("limits/time", time_limit)

    # Add variables
    x = {}
    for u, v in edges:
        x[(u, v)] = model.addVar(vtype="C", name=f"x_{u}_{v}", lb=0, ub=1)

    # Add degree constraints
    for v in range(n):
        model.addCons(quicksum(x[a] for a in delta({v}, edges)) == 2, name=f"degree_{v}")

    # Set the objective function
    model.setObjective(quicksum(x[a] * G[a[0]][a[1]][cost] for a in edges))

    # Solve the initial model
    model.optimize()

    # Get the initial objective value
    if verbose:
        obj = model.getObjVal()
        print(f"Initial Objective value: {obj}")

    # Build graph from solution
    H = nx.Graph()
    for u, v in edges:
        x_u_v = max(model.getVal(x[(u, v)]), 0)  # Just in case of numerical issues
        H.add_edge(u, v, weight=x_u_v)

    # Compute minimum cut
    cut_val, partition = nx.stoer_wagner(H, weight="weight")
    W = set(partition[0])

    # Add cuts iteratively
    cut_counter = 0
    while cut_val < 2 - tol:
        model.freeTransform()
        cut_counter += 1
        model.addCons(quicksum(x[a] for a in delta(W, edges)) >= 2, name=f"cut_{cut_counter}")
        model.optimize()

        if verbose and model.getObjVal() > obj:
            obj = model.getObjVal()
            print(f"Cut {cut_counter}, Objective value: {model.getObjVal()}")

        H = nx.Graph()
        for u, v in edges:
            x_u_v = max(model.getVal(x[(u, v)]), 0)  # Just in case of numerical issues
            H.add_edge(u, v, weight=x_u_v)

        cut_val, partition = nx.stoer_wagner(H, weight="weight")
        W = set(partition[0])

    # Return solution, objective value, and runtime
    solution = {e: model.getVal(var) for e, var in x.items()}
    return model.getObjVal(), solution, model.getSolvingTime()

def write_tsplib(G, filename, cost="weight"):
    """
    Write a TSPLIB file from a NetworkX graph.

    Parameters
    ----------
    G : networkx.Graph
        The graph to write.
    filename : str
        The name of the file to write.
    cost : str
        The edge attribute to use as cost. Default: 'weight'
    """
    problem = create_tsp_problem_object(G, cost=cost)
    with open(filename, "w") as f:
        problem_str = str(problem).replace("EDGE_WEIGHT_SECTION:", "EDGE_WEIGHT_SECTION:\n")
        f.write(problem_str)

def from_edge_list_to_tour(E_keep, n):
    """
    Starts from a list of nodes [(i1, i2) , (i3, i4)] ... and returns a tour, starting from 0, ending in 0

    Parameters
    ----------
    E_keep : list
        List of edges, that will be kept like that
    n : int
        The number of nodes we are talking about

    Returns
    -------
    Ls : list
        List of nodes, starting from 0, being a tour
    """
    # Work with E!
    E = E_keep.copy()

    current_node = 0
    Ls = [current_node]

    while len(Ls) < n + 1: # Bc it starts and ends with 0
        # Get the next edge
        next_edge = next(filter(lambda e: current_node in e, E), None)

        # Remove next edge from E
        E.remove(next_edge)

        # Get the other node
        u, v = next_edge

        if u == current_node:
            Ls.append(v)
            current_node = v
        elif v == current_node:
            Ls.append(u)
            current_node = u

    return Ls